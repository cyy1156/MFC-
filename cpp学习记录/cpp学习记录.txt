2026.1.18
简单了解了cpp的语法知识
2026.1.19
简单学习了cpp的知识开始对计算机实时仿真软件进行学习
2026.1.21
跟踪系数	控制对象 “追目标值的积极性”	
调大：对象快速冲向目标（比如温度从 20℃猛升到 25℃），但容易冲过头（超调）；
调小：对象慢慢靠近目标，平稳但反应慢

抗扰系数	控制对象 “抵抗外界干扰的能力”	
调大：外界干扰（比如开窗导致温度下降）时，对象能快速调整（比如加大加热功率），不容易跑偏；
调小：抗干扰弱，干扰一来就偏离目标值

控制步长	控制对象 “一次调整的步数”	
调大：一次规划未来多步的控制量，控制更精准，但反应变慢（比如电机调速会卡顿）；
调小：反应快、实时性好，适合需要快速响应的场景
优化步长	控制对象 “预判未来的眼光长短”	
调大：能预判未来更长时间的变化（比如提前知道温度会持续下降），控制更稳；
调小：只看眼前，容易 “短视” 导致控制波动
优化权	控制对象 “优先保证精准度”	
调大：对象死死盯着目标值（比如必须精准到 25℃），哪怕控制量猛增猛减；
调小：精准度让步，控制量变化平缓
控制权	控制对象 “优先保证动作平稳”	
调大：对象动作温柔（比如加热功率慢慢升），保护设备（比如加热器、电机），但精准度会下降；
调小：为了精准，动作可以 “猛” 一点
一句话总结核心逻辑
想让控制对象反应快、追目标猛 → 调大跟踪系数，调小控制权；
想让控制对象抗干扰强、不跑偏 → 调大抗扰系数；
想让控制对象动作稳、保护设备 → 调大控制权；
想让控制对象预判准、长期稳 → 调大优化步长（但别太大，不然反应慢）
RealCtroDoc里面的析构函数
为什么要算法模块的删除顺序是这样的
一、核心原则：「正在用的资源不能删，删了就崩溃」
这是最基础、最关键的原因 —— 就像你不能把正在用的杯子扔了，程序也不能删除正在运行的算法对象：
假设当前系统正在用「PID 控制」（m_Algrithem=PID），说明m_pPidMode这个对象正在被程序调用（比如实时计算控制量）；
如果此时删除m_pPidMode，程序运行到 “用这个对象计算” 的代码时，就会找不到对象（空指针），直接崩溃；
所以代码里加了if(m_Algrithem!=PID)：只有当前不用 PID 算法时，才敢删m_pPidMode，正在用就保留。
同理，预测 / 专家 / 模糊 / 自适应控制的释放逻辑都是一样的：只删 “闲置” 的算法对象，保留 “正在工作” 的。
二、特殊规则：NEURALPID/FNPID 为什么全部保留？
代码里有个前提条件if((m_Algrithem!=NEURALPID)&&(m_Algrithem!=FNPID))，意思是 “如果当前用的是神经网络 PID / 模糊神经网络 PID，所有算法对象都不删”，原因大概率是：
依赖关系：神经网络 PID（NEURALPID）、模糊神经网络 PID（FNPID）不是 “独立算法”，而是基于基础算法（PID / 模糊 / 预测）改造的 —— 比如 NEURALPID 可能需要调用 PID 的核心逻辑，FNPID 可能依赖模糊控制的参数；
如果删了基础算法对象：比如删了m_pPidMode，NEURALPID 算法运行时要用到 PID 的参数，就会找不到资源，导致崩溃；
妥协方案：为了避免复杂的依赖检查，开发人员直接规定 “用这两种高级算法时，所有基础算法对象都保留”—— 虽然会多占用一点内存，但能 100% 避免崩溃（工业软件优先保证稳定，而非极致节省内存）。
三、补充：为什么不 “创建时删旧的，只留当前用的”？
你可能会问 “为什么不在切换算法时删不用的，非要等到析构时才删？”，原因是：
工业控制要 “无缝切换”：比如从 PID 切到预测控制，需要先加载预测控制参数，确认能运行后，再停 PID—— 如果切算法时立刻删 PID 对象，万一预测控制加载失败，系统就没算法可用了，会导致控制对象失控（比如加热器一直加热）；
析构时统一清理更安全：析构函数是程序 “最后一步”（关闭 / 退出时执行），此时系统已经停止控制，所有算法都不再工作，这时删闲置对象既安全，又能避免内存泄漏。
总结
算法对象这样释放的核心逻辑就 2 点：
安全第一：正在运行的算法对象绝对不删，避免程序崩溃 / 控制失控；
处理依赖：高级算法（NEURALPID/FNPID）依赖基础算法，所以全部保留，优先保证系统稳定；
（额外）工业软件的特点：宁可多留一点内存，也不冒 “崩溃 / 失控” 的风险，这和普通软件的内存优化思路不一样。
