# 实时控制系统客户端-服务器通信实现详解

## 概述
这是一个基于MFC的实时控制系统，使用自定义协议进行客户端-服务器通信。客户端通过界面操作发送命令，服务器接收并处理消息，实现控制逻辑和状态更新。

## 架构概述
- **客户端**：负责用户界面交互，发送控制命令。
- **服务器**：接收消息，执行控制算法，更新状态并广播给所有客户端。
- **协议**：使用`CMsg`类封装消息，包含`CSysForm`系统表单，参数以链表形式存储。

## 消息结构
- **CMsg**：消息基类，包含连接状态和系统表单指针。
- **CSysForm**：系统表单，包含发送/接收模式和各种参数列表。
- **CParaList**：参数链表，每个节点包含名称（字符串）、数据类型和值（数值）。

## 通信流程

### 1. 用户界面点击响应
假设客户端是另一个MFC应用程序（项目中未包含，但基于服务器代码推断）：

```cpp
// 客户端代码示例（假设）
void CClientView::OnStartButtonClicked()
{
    // 设置消息模式
    m_pSysForm->m_SendMode = CONTROLSTATUS;
    
    // 设置参数：启动状态为TRUE
    m_pCtrlStatuList->SetData((void*)&bStart); // bStart = TRUE
    
    // 发送消息
    SendMsg(&m_msg);
}
```

### 2. 消息发送
- 客户端调用`SendMsg(CMsg* pMsg)`，序列化消息并通过套接字发送。
- 消息包含协议标记"DcSys"和相应数据。

### 3. 服务器接收处理
服务器在`ProcessPendingRead`中处理：

```cpp
void CRealCtrlDoc::ProcessPendingRead(CClientSocket * pSocket)
{
    do
    {
        ReadMsg(pSocket); // 接收并反序列化消息到m_msg
        if (!m_msg.m_bConnect)	
        {
            CloseSocket(pSocket);
            break;
        }
        else
        {
            switch (m_pSysForm->m_ReceaveMode) // 根据接收模式处理
            {
            case CONTROLSTATUS:
                {
                    BOOL bstate = m_bStart;
                    m_pCtrlStatuList->GetData((void*)&m_bStart); // 从消息获取启动状态
                    if (bstate != m_bStart)
                    {
                        if (m_bStart)
                            Start(); // 调用启动方法
                        else
                            Stop(); // 调用停止方法
                    }
                    // 类似处理暂停状态
                }
                break;
            // 其他case...
            }
        }
    } while (!pSocket->m_pArchiveIn->IsBufferEmpty());
}
```

### 4. 状态更新和广播
- `Start()`方法更新内部状态，初始化控制算法，并调用`UpdateClients()`广播给所有客户端。

```cpp
void CRealCtrlDoc::Start()
{
    m_bStart = TRUE;
    m_pCtrlStatuList->SetData((void*)&m_bStart);
    m_pSysForm->m_SendMode = CONTROLSTATUS;
    UpdateClients(); // 广播消息
    
    // 初始化控制参数
    m_nCounter = 0;
    m_ControlCounter = 0;
    // ...
    
    // 根据算法启动相应控制器
    switch (m_Algrithem)
    {
    case PID:
        m_Pid.Start();
        break;
    // ...
    }
}
```

### 5. UI更新
服务器更新视图：

```cpp
case GIVENVALUE:
    {
        m_pSetValueList->GetData((void*)&m_SysInfo.GivenValue);
        // 获取视图并更新UI
        CMainFrame* pFrm = (CMainFrame*)(AfxGetApp()->m_pMainWnd);
        POSITION pos = GetFirstViewPosition();   
        CRealCtrlView* pView = (CRealCtrlView*)GetNextView(pos);
        if (pFrm->m_CurrentView == 0)
            pView = (CRealCtrlView*)GetNextView(pos);
        pView->m_pGivenValueScreen->SetText(0.1f * m_SysInfo.GivenValue);
        pView->m_pGVslide->SetCurrentValue((int)m_SysInfo.GivenValue);
    }
    break;
```

## 关键类和方法

### CRealCtrlDoc
- **成员变量**：
  - `m_msg`：存储接收/发送的消息。
  - `m_pSysForm`：系统表单指针。
  - 各种参数列表：`m_pSetValueList`、`m_pCtrlStatuList`等。
- **关键方法**：
  - `ProcessPendingRead`：处理接收消息。
  - `Start/Stop/Pause`：控制状态管理。
  - `UpdateClients`：广播消息给客户端。

### CSysForm
- **序列化**：`Serialize`方法根据`m_SendMode`序列化不同数据。
- **参数列表**：`AccessList`处理链表序列化。

### CParaList
- **数据存储**：联合体`PARATYPE`存储不同类型值。
- **序列化**：根据`m_ArchiveMode`序列化名称和值。

## 控制算法集成
- 支持多种算法：PID、预测控制、自适应等。
- 在`Control()`方法中根据`m_Algrithem`调用相应算法计算控制值。

## 总结
1. **前端点击**：触发客户端设置消息参数。
2. **消息发送**：序列化并通过套接字传输。
3. **服务器处理**：反序列化，根据模式执行逻辑。
4. **状态更新**：修改内部变量，调用算法。
5. **广播响应**：发送更新消息给所有客户端，更新UI。

这个实现支持实时监控和远程控制，适用于工业自动化场景。